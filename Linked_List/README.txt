<각 문제별 접근 방법>

문제 2.1)
 1장에서 비트와이즈 연산으로 중복을 찾았던 것 처럼 그대로 적용하여 중복된 문자를 찾아주면 된다.


문제 2.2)
 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 이라면 어떻게 찾을 것인가.
만약 뒤에서 n을 찾고 싶다면 맨 앞 커서와 앞에서 n커서 두개를 두고 같이 이동시킨다. 뒤의 커서가 NULL(리스트의 끝)을 만나면 앞의 커서가 가리키는 것이 뒤에서 n번째 요소가 된다.


문제 2.3)
 1-> 2 -> 3-> 4-> 5 의 리스트에서 중간 노드의 정보만 알고있다면, 즉 삭제하고자 하는 노드의 정보를 알 수 없다면 어떻게 할지가 이 문제의 핵심이다. 
 이 문제해결의 핵심 아이디어는 앞 노드를 찾으려고 노력할 필요가 없다는 것이다. 즉 3을 삭제하고자 한다면 3의 next 값을 3에 복사하고 이제 값이 4가된 노드 3 next의 연결을 5와 해주면 끝이다.


문제 2.4)
 단순히 carry를 이용하여 값의 올림을 저장하고 최종 리스트에 저장하면 되는 문제.


문제 2.5)
 이문제는 총 3가지 단계로 이루어진다. 
1단계> 주어진 linkedlist가 circular 인지 확인한다.
HOW? -> fast runner(2씩 이동)와 slow runner(1씩 이동)를 지정하여 두 커서가 만난다면 loop 가 존재하는 것이다. 만약 만나지 않는 다면 빠른 커서는 NULL을 만난다.

2단계> 위에서 찾은 collision point와 list의 시작지점부터 동일한 속도(1씩이동)로 커서를 이동시킨다. 이때 두 커서가 만나게 되는 지점이 loop의 시작 지점이 된다. (list의 시작 지점부터 충동 지점까지가 loop의 길이가 되는데 이 말은 충돌지점부터 loop 시작점 까지의 거리와 list의 시작점부터 loop의 거리가 같다는 말과 같다.)
